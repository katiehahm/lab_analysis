function [estimateID] = recursive_stepID(curr_ID_labels, real_impact_times, step_times, step_o, step_x)

powerN = length(step_times)

allcombinations = ones(1, powerN); % no x's

for i = round(powerN/3):round(2*powerN/3) % know they at least have to be 33% of total footsteps
    curr_arr = ones(1,powerN);
    curr_arr(1:i) = 2;
    P = uniqueperms(curr_arr);
    allcombinations = [allcombinations; P];
end

allcombinations(1,:) = []; % delete first row from initialization
[allcombN,~] = size(allcombinations);
scores = zeros(allcombN,1);
diff_matrix = zeros(allcombN, powerN);

for i = 1:allcombN
    curr_arr = allcombinations(i,:);
    one_idx = find(curr_arr == 1);
    two_idx = find(curr_arr == 2);
    score = 0;
    
    for j = 2:length(one_idx)
        curr_i = one_idx(j);
        past_i = one_idx(j-1);
        curr_diff = abs(step_times(curr_i) - step_times(past_i));
        diff_matrix(i,curr_i) = curr_diff;
        score = score + abs(curr_diff - step_o);
    end
    for k = 2:length(two_idx)
        curr_i = two_idx(k);
        past_i = two_idx(k-1);
        curr_diff = abs(step_times(curr_i) - step_times(past_i));
        diff_matrix(i,curr_i) = curr_diff;
        score = score + abs(curr_diff - step_x);
    end
    scores(i) = score;
end

[~,idx] = min(scores);

% display current state of step times
figure;
real_o = find(curr_ID_labels == 1);
real_x = find(curr_ID_labels == 2);
plot(real_impact_times(real_o),0,'bo')
hold on
plot(real_impact_times(real_x),0,'bx')
hold on
plot(step_times, 0.4, 'rx')
ylim([-1 1])

est_o = find(allcombinations(idx,:) == 1);
est_x = find(allcombinations(idx,:) == 2);
figure;
plot(est_o,0,'bo')
hold on
plot(est_x,0,'bx')

plot(step_times(est_o),0.5,'ro')
plot(

% perform adding impact first (more accurate?)
% if any step time is 1.5x larger than largest step time, missing an impact
diff_matrix(idx,:)
diff_matrix(idx,est_o)
bigidxone = find(diff_matrix(idx,est_o) > step_o*1.8);
diff_matrix(idx,est_x)
bigidxtwo = find(diff_matrix(idx,est_x) > step_x*1.8);
bigidx = sort([est_o(bigidxone); est_x(bigidxtwo)]);
if ~isempty(bigidx)
    bigidx(1)
    % add element at bigidx-1 to duplicate it
    step_times = [step_times(1:bigidx(1)-1); step_times(bigidx(1)-1:end)];
    [estimateID] = recursive_stepID(curr_ID_labels, real_impact_times, step_times, step_o, step_x);
else
    % if all element in a column in diff_matrix is too small, delete, recursive
    smallidxone = find(diff_matrix(idx,est_o) < step_o/1.5);
    smallidxtwo = find(diff_matrix(idx,est_x) < step_x/1.5);
    smallidx = sort([est_o(smallidxone); est_x(smallidxtwo)]);
    if ~isempty(smallidx)
        % delete element at smallidx
        step_times = [step_times(1:smallidx(1)-1); step_times(smallidx(1)+1:end)];
        [estimateID] = recursive_stepID(curr_ID_labels, real_impact_times, step_times, step_o, step_x);
    end
end

estimateID = allcombinations(idx,:);

end

