%% 3/3/20 post lab1
clear all
close all
load('footsteps_013020.mat')
load('multitaps')

Fs = 192e+3;
d = multitap_all_A4F6;

% adjust data so it is visually corresponding to sensor quadrants
dRT = d(:,RT);
dLT = d(:,LT);
dRB = d(:,RB);
dLB = d(:,LB);
d(:,1) = dLT;
d(:,2) = dRT;
d(:,3) = dLB;
d(:,4) = dRB;
loc_names = {'left top', 'right top', 'left bottom', 'right bottom'};
n = length(dRB);

figure; % raw data
hold on
for i = 1:4
    subplot(2,2,i)
    title_str = 'raw data ';
    plot(d(:,i))
    title([title_str, loc_names(i)])
end

figure; % frequency spectrum
hold on
for i = 1:4
    subplot(2,2,i)
    title_str = 'frequency spectrum ';
    [X, F] = pwelch(d(:,i),[],[],[],Fs);
    plot(F, pow2db(X))
    title([title_str, loc_names(i)])
end

%% filter
filt = zeros(n, 4);
for i = 1:4
    b = fir1(48, 20000/Fs, 'low');
    filt(:,i) = filter(b, 1, d(:,i));
%     filt(:,i) = lowpass(d(:,i), 20000, Fs);
end

figure; % filtered signal in time domain
hold on
for i = 1:4
    subplot(2,2,i)
    title_str = 'filtered data ';
    plot(filt(:,i))
    title([title_str, loc_names(i)])
end


%% find peaks
% [p_idx, p_val] = findPeaks(filt, Fs);
% 
% this is just to debug findpeaks!!!!!!!
d_length = length(d(:,1));
overlap = 0.5;
frame_sec = 0.15;
frame_length = round(frame_sec*Fs);  % length of each data frame (samples)
frame_step = round(frame_length*(1-overlap));  % amount to advance for next data frame
frame_N = floor((d_length-(frame_length-frame_step))/frame_step); % total number of frames
t = ([0:frame_N-1]*frame_step+frame_length)/Fs;

p_idx = zeros(frame_N, 4);
p_val = zeros(frame_N, 4);

% find peak per frame
for i = 1:frame_N
    for j = 1:4
        data = d(:,j);
        seg = data(((i-1)*frame_step+1):((i-1)*frame_step+frame_length));
        [~, idx] = max(seg);
        p_idx(i,j) = idx + (i-1)*frame_length*(1-overlap);
    end
end

% remove duplicates
for i = 1:4
    new_p_idx = unique(p_idx(:,i));
    p_idx(:,i) = [new_p_idx; zeros(frame_N - length(new_p_idx), 1)];
end

% filter out repeated peaks
for i = 1:4
    peaks = p_idx(:,i);
    prev = peaks(1);
    idx_elim = [];
    thresh = 10000; % time threshold (min time between hits)
    for j = 2:length(peaks)
        if peaks(j) - prev < thresh
            idx_elim(end+1) = j;
        end
        prev = peaks(j);
    end
    peaks(idx_elim) = [];
    p_idx(:,i) = [peaks; zeros(frame_N - length(peaks), 1)];
end

% assign values corresponding to peak indexes
for i = 1:4
    sing_data = d(:,i);
    for j = 1:length(p_idx(:,i))
        ind = round(p_idx(j,i));
        if ind ~= 0
            p_val(j,i) = sing_data(round(p_idx(j,i)));
        end
    end
end

% eliminate any false peaks (peaks in noise)
threshold = 0.005; % min magnitude of valid peak
for i = 1:4
    idx_to_elim = find(p_val(:,i) < threshold);
    peaks = p_val(:,i);
    idxs = p_idx(:,i);
    peaks(idx_to_elim) = [];
    idxs(idx_to_elim) = [];
    p_val(:,i) = [peaks; zeros(frame_N - length(peaks), 1)];
    p_idx(:,i) = [idxs; zeros(frame_N - length(idxs), 1)];
end

elim = 0;
for i = 1:frame_N
    if p_val(i,1) == 0
        elim = i;
        break;
    end
end
p_val = p_val(1:elim, :);
p_idx = p_idx(1:elim, :);

figure; % plot the peaks
hold on
for i = 1:4
    subplot(2,2,i)
    title_str = 'filtered data with peaks ';
    plot(filt(:,i))
    hold on
    plot(p_idx(:,i), p_val(:,i), 'ro')
    title([title_str, loc_names(i)])
end

%% find onset of first disturbance
disturb_RT = ones(1, length(peaks_RT));
disturb_RB = ones(1, length(peaks_RT));
disturb_LT = ones(1, length(peaks_RT));
disturb_LB = ones(1, length(peaks_RT));
for i = 1:length(peaks_RT)
    pk_RT = peaks_RT(i);
    pk_RB = peaks_RB(i);
    pk_LT = peaks_LT(i);
    pk_LB = peaks_LB(i);
    tolerance = 0.002e+05;
    for j = 1:tolerance
        val = RTs(round(pk_RT - tolerance + j));
        if abs(val) > 0.001 && disturb_RT(i) == 1
            disturb_RT(i) = pk_RT - tolerance + j;
        end
        val = RBs(round(pk_RB - tolerance + j));
        if abs(val) > 0.001 && disturb_RB(i) == 1
            disturb_RB(i) = pk_RB - tolerance + j;
        end
        val = LTs(round(pk_LT - tolerance + j));
        if abs(val) > 0.001 && disturb_LT(i) == 1
            disturb_LT(i) = pk_LT - tolerance + j;
        end
        val = LBs(round(pk_LB - tolerance + j));
        if abs(val) > 0.001 && disturb_LB(i) == 1
            disturb_LB(i) = pk_LB - tolerance + j;
        end
    end
end

disturb_val_RT = ones(1, length(peaks_RT));
disturb_val_RB = ones(1, length(peaks_RB));
disturb_val_LT = ones(1, length(peaks_LT));
disturb_val_LB = ones(1, length(peaks_LB));
for i = 1:length(peaks_RT)
    disturb_val_RT(i) = RTs(round(disturb_RT(i)));
end
for i = 1:length(peaks_RB)
    disturb_val_RB(i) = RBs(round(disturb_RB(i)));
end
for i = 1:length(peaks_LT)
    disturb_val_LT(i) = LTs(round(disturb_LT(i)));
end
for i = 1:length(peaks_LB)
    disturb_val_LB(i) = LBs(round(disturb_LB(i)));
end

subplot(2,2,1)
hold on
plot(disturb_RT, disturb_val_RT, 'ro')
subplot(2,2,2)
hold on
plot(disturb_RB, disturb_val_RB, 'ro')
subplot(2,2,3)
hold on
plot(disturb_LT, disturb_val_LT, 'ro')
subplot(2,2,4)
hold on
plot(disturb_LB, disturb_val_LB, 'ro')

%% perform triangulation
% assumes all vectors are the same length!!!!!
npeaks = length(peaks_LB);
diff_RT = ones(1, npeaks);
diff_RB = ones(1, npeaks);
diff_LT = ones(1, npeaks);
diff_LB = ones(1, npeaks);
for i = 1:npeaks
    i_RT = peaks_RT(i);
    i_RB = peaks_RB(i);
    i_LT = peaks_LT(i);
    i_LB = peaks_LB(i);
    min_idx = min([i_RT, i_RB, i_LT, i_LB]);
    diff_RT(i) = i_RT - min_idx;
    diff_RB(i) = i_RB - min_idx;
    diff_LT(i) = i_LT - min_idx;
    diff_LB(i) = i_LB - min_idx;
end
figure;
bar([transpose(diff_RT), transpose(diff_RB), transpose(diff_LT), transpose(diff_LB)])
legend('right top', 'right bottom', 'left top', 'left bottom')
title('Triangulation: time delays of each sensor from peaks')
xlabel('Hit')
ylabel('samples (*1000/Fs = ms)')

diff_RT = ones(1, npeaks);
diff_RB = ones(1, npeaks);
diff_LT = ones(1, npeaks);
diff_LB = ones(1, npeaks);
for i = 1:npeaks
    i_RT = disturb_RT(i);
    i_RB = disturb_RB(i);
    i_LT = disturb_LT(i);
    i_LB = disturb_LB(i);
    min_idx = min([i_RT, i_RB, i_LT, i_LB]);
    diff_RT(i) = i_RT - min_idx;
    diff_RB(i) = i_RB - min_idx;
    diff_LT(i) = i_LT - min_idx;
    diff_LB(i) = i_LB - min_idx;
end
figure;
bar([transpose(diff_RT), transpose(diff_RB), transpose(diff_LT), transpose(diff_LB)])
legend('right top', 'right bottom', 'left top', 'left bottom')
title('Triangulation: time delays of each sensor from signal onset')
xlabel('Hit')
ylabel('samples (*1000/Fs = ms)')

mag_diff_RT = ones(1, npeaks);
mag_diff_RB = ones(1, npeaks);
mag_diff_LT = ones(1, npeaks);
mag_diff_LB = ones(1, npeaks);
for i = 1:npeaks
    mag_RT = val_RT(i);
    mag_RB = val_RB(i);
    mag_LT = val_LT(i);
    mag_LB = val_LB(i);
    min_mag = min([mag_RT, mag_RB, mag_LT, mag_LB]);
    min_mag = mag_LT; % comment this out later!!!!
    mag_diff_RT(i) = mag_RT - min_mag;
    mag_diff_RB(i) = mag_RB - min_mag;
    mag_diff_LT(i) = mag_LT - min_mag;
    mag_diff_LB(i) = mag_LB - min_mag;
end
figure;
bar([transpose(mag_diff_RT), transpose(mag_diff_RB), transpose(mag_diff_LT), transpose(mag_diff_LB)])
legend('right top', 'right bottom', 'left top', 'left bottom')
title('Triangulation: magnitude differences of each sensor at peak')
xlabel('Hit')
ylabel('Volts (+50 dB gain)')

% coordinate prediction by triangulation
% result = '';
% for i = 1:npeaks
%     blue = diff_RT(i);
%     orange = diff_RB(i);
%     purple = diff_LB(i);
%     yellow = diff_LT(i);
%     if blue == 0 
%        % quadrant 1
%        if orange < 105
%            if purple > 140
%                result = append(result, ', A4');
%            else
%                result = append(result, ', A5'); % or B5
%            end
%             
%        end
%        if yellow > 300
%            if orange < 140
%                result = append(result, 'B4');
%            end
%     end
%    if dlb > max(drt, drb, dlt) + 200
%        result = append(result, ', A6');
%    end
%    
% end

% % coordinate prediction by sys of eq
% coordinates = ones(3, npeaks); % x, y, error
% top_l = 48;
% % bot_l = 48;
% left_l = 48;
% % right_l = 48;
% for i = 1:npeaks
%     syms d x y % distance to closest hit, x/y coordinate of hit
%     dist_RT = diff_RT(i) + d;
%     dist_RB = diff_RB(i) + d;
%     dist_LT = diff_LT(i) + d;
%     dist_LB = diff_LB(i) + d;
%     eq1 = x^2 + y^2 == dist_LT^2;
%     eq2 = (top_l - x)^2 + y^2 == dist_RT^2;
%     eq3 = x^2 + (left_l-y)^2 == dist_LB^2;
%     eq4 = (top_l - x)^2 + (left_l - y)^2 == dist_RB^2;
%     [d_val, x_val, y_val] = vpasolve([eq1, eq2, eq3], [d, x, y], [0, 0, 0]);
%     error = abs( (top_l - x_val)^2 + (left_l - y_val)^2 - (diff_RB(i) + d_val)^2 );
%     coordinates(1, i) = x_val;
%     coordinates(2, i) = y_val;
%     coordinates(3, i) = error;
% end
